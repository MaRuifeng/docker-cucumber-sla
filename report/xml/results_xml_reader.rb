# This utility class contains a reader that reads the TESTS-<feature name>.xml
# files generated by the automated Cucumber test
# and produces an Array that contains a list of test suite (feature) execution results
# and test case (scenario) execution results for RTC publisher.
#
# Maintainer: ruifengm@sg.ibm.com
# Date: 2016-Jul-14

require_relative 'results_xml_common'

class ResultsXMLReader < ResultsXMLCommon

  @@class_name = self.name

  attr_accessor :status_arr
  attr_reader :test_suite_result_list

  def initialize(xml_dir, log_dir, build_name, status_arr = Constants::TEST_RESULT_STATUS.values)
    super(xml_dir, log_dir, nil)
    @test_suite_result_list = nil
    @build_name = build_name
    @status_arr = status_arr
  end

  # Construct and return test suite results array
  def construct_test_suite_result_list
    ReportLog.entering(@@class_name, __method__.to_s)
    @test_suite_result_list = Array.new
    get_test_xml_files.each do |file_path|
      ReportLog.info("Fetching test results from file #{file_path}...")
      @test_suite_result_list.push(fetch_test_suite_result_from_xml(file_path, @status_arr))
    end
    ReportLog.exiting(@@class_name, __method__.to_s)
  end

  # Fetch test results from a single XML file as a hash
  # with key values match those required by the RTC web client APIs
  def fetch_test_suite_result_from_xml(xml_path, status_arr = Constants::TEST_RESULT_STATUS.values)
    ReportLog.entering(@@class_name, __method__.to_s)
    xml_file = File.new(xml_path)
    owner = get_test_suite_owner(xml_path)
    xml_doc = Document.new(xml_file)
    test_suite_result = Hash.new
    xml_doc.elements.each('testsuite') do |e|
      test_suite_result['TestSuiteName'] = e.attribute('name').value
      test_suite_result['Owner'] = owner
      test_suite_result['TestPackage'] = get_test_package(xml_path)
      # build_name = "ivt_#{rand(12).to_s}.#{rand(10).to_s}.20160719-0602.#{rand(100).to_s}"
      # build_name = ENV['APP_BUILD']
      build = get_build_info_from_name(@build_name)
      test_suite_result['Build'] = build
      test_suite_result['TestCount'] = e.attribute('tests').value.to_i
      test_suite_result['ErrorCount'] = e.attribute('errors').value.to_i
      test_suite_result['FailureCount'] = e.attribute('failures').value.to_i
      test_suite_result['ExecutionTimestamp'] = Time.now.getutc.strftime('%FT%T').to_s # No timestamp given in XML, use UTC now
      test_suite_result['ExecutionTimeInSeconds'] = e.attribute('time').value.to_i # Get integer part only
      test_suite_result['DueDate'] = get_due_date.to_s
      test_suite_result['TestCaseResults'] = construct_test_case_result_list(e, status_arr)
    end
    ReportLog.exiting(@@class_name, __method__.to_s)
    return test_suite_result
  end

  private

  def construct_test_case_result_list(test_suite, status_arr)
    ReportLog.entering(@@class_name, __method__.to_s)
    test_case_result_list = Array.new
    test_suite_name = test_suite.attribute('name').value
    test_suite.elements.each('testcase') do |e|
      test_case_result = Hash.new
      test_case_result['TestCaseName'] = e.attribute('name').value
      test_case_result['TestSuite'] = test_suite_name
      test_case_result['TestCaseClassPath'] = e.attribute('classname').value
      test_case_result['RQMTestCaseId'] = 0   # TODO
      test_case_result['ExecutionTimeInSeconds'] = e.attribute('time').value.to_i # Get integer part only

      if @log_dir.nil?
        test_case_result['TestLogLink'] = nil
      else
        log_link = get_test_suite_log_link(test_suite_name)
        test_case_result['TestLogLink'] = log_link
      end

      e.elements.to_a('failure').nil? ? is_failure = false : true
      e.elements.to_a('error').nil? ? is_error = false : true

      status_arr.each do |status|
        case status
          when Constants::TEST_RESULT_STATUS[:failure]
            e.elements.each('failure') do |f|
              test_case_result['FailureMessage'] = get_all_node_text(f)
              test_case_result['FailureType'] = f.attribute('type').value
              test_case_result['Status'] = status
            end
            test_case_result_list.push(test_case_result) if is_failure
          when Constants::TEST_RESULT_STATUS[:error]
            e.elements.each('error') do |err|
              test_case_result['ErrorMessage'] = get_all_node_text(err)
              test_case_result['ErrorType'] = err.attribute('type').value
              test_case_result['Status'] = status
            end
            test_case_result_list.push(test_case_result) if is_error
          when Constants::TEST_RESULT_STATUS[:success]
            test_case_result['Status'] = status
            test_case_result_list.push(test_case_result) unless (is_error || is_failure)
          else
            raise "Unknown test result status value #{status} received. Accept only #{Constants::TEST_RESULT_STATUS.values}."
        end
      end
    end
    ReportLog.exiting(@@class_name, __method__.to_s)
    return test_case_result_list
  end

  def get_all_node_text(node)
    # Get all text of an XML node with CDATA tags
    all_text = node.text
    node.cdatas.each do |e|
      all_text = all_text + e.to_s
    end
    return all_text
  end

  def get_due_date
    # No execution timestamp provided; Set due date as now + due_working_days
    time = Time.now.getutc
    # (0..data_for(:RTC_work_item_attr)['due_working_days']).each do
    (0..Constants::DUE_WORKING_DAYS).each do
      time = time + (60 * 60 * 24) # add a day
      while time.saturday? || time.sunday? do
        time = time + (60 * 60 * 24) # add a day
      end
    end
    return time.strftime('%FT%T')
  end

  def get_build_info_from_name(build_name)
    # sample build names: ivt_10.4.20160719-1900.164, sla-ui.ivt_10.4.20160719-1900.164, sla-ee.ivt_10.4.20160719-1900.164, Development.20160719-1900.164
    build = Hash.new
    begin
      build['BuildName'] = build_name

      # branch_reg = /\Aivt_[0-9]+\.[0-9]|Development/
      branch_reg = /ivt_[0-9]+\.[0-9]|Development/ # only ivt or Development branch are allowed for reporting
      branch = build_name.match(branch_reg).to_s
      build['GitBranch'] = branch
      if (branch == 'Development')
        build['Sprint'] = 'Tip'
      else
        build['Sprint'] = branch.split('_').last
      end

      version_reg = /[0-9]+\z/
      build['BuildVersion'] = build_name.match(version_reg).to_s

      time_reg = /[0-9]{8}-[0-9]{4}/
      time = build_name.match(time_reg).to_s
      year = time[0..3].to_i
      month = time[4..5].to_i
      day = time[6..7].to_i
      minute = time[-2..-1].to_i
      hour = time[-4..-3].to_i
      # build server takes EDT time
      build['BuildTimestamp'] = Time.new(year, month, day, hour, minute, 0, '-04:00').utc.strftime('%FT%T').to_s
    rescue Exception => error
      ReportLog.error("#{error.class}: #{error.message}")
      raise "Unable to pass the build name #{build_name} supplied. Accept only format 'sprint.YYYYMMDD-HHMM.build_ver_num' or 'Development.YYYYMMDD-HHMM.build_ver_num'."
    end
    build
  end

end